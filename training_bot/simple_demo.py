#!/usr/bin/env python3
"""
üéØ –£–ü–†–û–©–ï–ù–ù–ê–Ø –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –ü–û–≠–¢–ê–ü–ù–û–ì–û –û–ë–£–ß–ï–ù–ò–Ø
XGBoost ‚Üí LSTM (—Å–∏–º—É–ª—è—Ü–∏—è) ‚Üí Ensemble
–ë–µ–∑ —Ç—è–∂–µ–ª—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∫–∞–∑–∞
"""

import os
import sys
import time
import json
import pickle
from datetime import datetime, timedelta
from typing import Dict, List, Tuple
import warnings

warnings.filterwarnings('ignore')

# –ë–∞–∑–æ–≤—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
try:
    import numpy as np
    import pandas as pd
    from sklearn.model_selection import train_test_split
    from sklearn.preprocessing import StandardScaler
    from sklearn.metrics import mean_squared_error, mean_absolute_error
    from sklearn.ensemble import RandomForestRegressor  # –í–º–µ—Å—Ç–æ XGBoost
    print("‚úÖ –ù–∞—É—á–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã")
except ImportError as e:
    print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {e}")
    print("üí° –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install numpy pandas scikit-learn")
    sys.exit(1)


class SimpleProgressiveTrainer:
    """–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ—ç—Ç–∞–ø–Ω—ã–π —Ç—Ä–µ–Ω–µ—Ä –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏"""
    
    def __init__(self, symbol: str = "EURUSD_DEMO"):
        self.symbol = symbol
        self.models = {}
        self.results = {}
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –ø–∞–ø–∫–∏ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        self.save_dir = f"simple_models/{symbol}"
        os.makedirs(self.save_dir, exist_ok=True)
        
        print(f"üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω Simple Progressive Trainer –¥–ª—è {symbol}")
    
    def create_demo_data(self) -> pd.DataFrame:
        """–°–æ–∑–¥–∞–Ω–∏–µ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        print("üé≤ –°–æ–∑–¥–∞–Ω–∏–µ —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö...")
        
        # –í—Ä–µ–º–µ–Ω–Ω–æ–π —Ä—è–¥ (1 –≥–æ–¥ —á–∞—Å–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö)
        end_date = datetime.now()
        start_date = end_date - timedelta(days=365)
        dates = pd.date_range(start=start_date, end=end_date, freq='H')
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã—Ö —Ü–µ–Ω EUR/USD
        np.random.seed(42)
        
        # –ë–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞ + —Ç—Ä–µ–Ω–¥ + —Å–ª—É—á–∞–π–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
        base_price = 1.1000
        trend = np.linspace(0, 0.05, len(dates))  # –ù–µ–±–æ–ª—å—à–æ–π –≤–æ—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥
        
        # –°–ª—É—á–∞–π–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å –∞–≤—Ç–æ–∫–æ—Ä—Ä–µ–ª—è—Ü–∏–µ–π
        returns = np.random.normal(0, 0.001, len(dates))
        for i in range(1, len(returns)):
            returns[i] += 0.15 * returns[i-1]  # Momentum —ç—Ñ—Ñ–µ–∫—Ç
        
        # –ò—Ç–æ–≥–æ–≤—ã–µ —Ü–µ–Ω—ã
        prices = base_price + trend + np.cumsum(returns)
        
        # OHLC –¥–∞–Ω–Ω—ã–µ
        df = pd.DataFrame({
            'timestamp': dates,
            'open': prices,
            'high': prices * (1 + np.abs(np.random.normal(0, 0.0003, len(dates)))),
            'low': prices * (1 - np.abs(np.random.normal(0, 0.0003, len(dates)))),
            'close': prices,
            'volume': np.random.randint(1000, 50000, len(dates))
        })
        
        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ high/low
        df['high'] = np.maximum(df[['open', 'close']].max(axis=1), df['high'])
        df['low'] = np.minimum(df[['open', 'close']].min(axis=1), df['low'])
        
        df.set_index('timestamp', inplace=True)
        
        print(f"üìä –°–æ–∑–¥–∞–Ω–æ {len(df)} –∑–∞–ø–∏—Å–µ–π —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö")
        return df
    
    def add_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤"""
        print("üîß –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤...")
        
        features_df = df.copy()
        
        # –°–∫–æ–ª—å–∑—è—â–∏–µ —Å—Ä–µ–¥–Ω–∏–µ
        for period in [5, 10, 20, 50]:
            features_df[f'sma_{period}'] = df['close'].rolling(window=period).mean()
            features_df[f'ema_{period}'] = df['close'].ewm(span=period).mean()
        
        # RSI (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–π)
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        features_df['rsi'] = 100 - (100 / (1 + rs))
        
        # MACD
        features_df['macd'] = features_df['ema_12'] - features_df['ema_26'] if 'ema_12' in features_df.columns else 0
        features_df['macd_signal'] = features_df['macd'].rolling(9).mean()
        
        # –î–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏
        features_df['returns'] = df['close'].pct_change()
        features_df['volatility'] = features_df['returns'].rolling(window=20).std()
        
        # –õ–∞–≥–æ–≤—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
        for lag in [1, 2, 3, 5, 10]:
            features_df[f'close_lag_{lag}'] = df['close'].shift(lag)
            features_df[f'returns_lag_{lag}'] = features_df['returns'].shift(lag)
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏
        features_df['high_low_ratio'] = df['high'] / df['low']
        features_df['price_change'] = df['close'] - df['open']
        features_df['price_range'] = df['high'] - df['low']
        
        # –¶–µ–ª–µ–≤–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è (—Å–ª–µ–¥—É—é—â–∞—è —Ü–µ–Ω–∞)
        features_df['target'] = df['close'].shift(-1)
        
        # –£–¥–∞–ª–µ–Ω–∏–µ NaN
        features_df = features_df.dropna()
        
        print(f"‚úÖ –°–æ–∑–¥–∞–Ω–æ {len(features_df.columns)} –ø—Ä–∏–∑–Ω–∞–∫–æ–≤")
        return features_df
    
    def prepare_data(self, df: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray, List[str]]:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è"""
        
        # –í—ã–±–æ—Ä –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ (–∏—Å–∫–ª—é—á–∞–µ–º —Ü–µ–ª–µ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –∏ –∏—Å—Ö–æ–¥–Ω—ã–µ —Ü–µ–Ω—ã)
        feature_columns = [col for col in df.columns 
                          if col not in ['target', 'open', 'high', 'low', 'close', 'volume']]
        
        X = df[feature_columns].values
        y = df['target'].values
        
        # –£–¥–∞–ª–µ–Ω–∏–µ NaN
        mask = ~(np.isnan(X).any(axis=1) | np.isnan(y))
        X = X[mask]
        y = y[mask]
        
        print(f"üìù –ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ {len(X)} –æ–±—Ä–∞–∑—Ü–æ–≤, {len(feature_columns)} –ø—Ä–∏–∑–Ω–∞–∫–æ–≤")
        
        return X, y, feature_columns
    
    def calculate_directional_accuracy(self, y_true: np.ndarray, y_pred: np.ndarray) -> float:
        """–†–∞—Å—á–µ—Ç —Ç–æ—á–Ω–æ—Å—Ç–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è"""
        if len(y_true) <= 1:
            return 0.0
        
        true_direction = np.diff(y_true) > 0
        pred_direction = np.diff(y_pred) > 0
        
        return np.mean(true_direction == pred_direction) * 100
    
    # ================== –≠–¢–ê–ü 1: RandomForest (–≤–º–µ—Å—Ç–æ XGBoost) ==================
    
    def train_forest_phase(self, X: np.ndarray, y: np.ndarray) -> Dict:
        """–≠–¢–ê–ü 1: –û–±—É—á–µ–Ω–∏–µ RandomForest - –±—ã—Å—Ç—Ä–æ –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ"""
        
        print("\n" + "="*60)
        print("üéØ –≠–¢–ê–ü 1: RandomForest (–±—ã—Å—Ç—Ä–æ –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ)")
        print("   –¶–µ–ª—å: –ü–æ–ª—É—á–∏—Ç—å –±–∞–∑–æ–≤—É—é –º–æ–¥–µ–ª—å –∑–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è")
        
        start_time = time.time()
        
        # –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, shuffle=False  # –í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä—è–¥—ã –Ω–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º
        )
        
        # –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
        scaler = StandardScaler()
        X_train_scaled = scaler.fit_transform(X_train)
        X_test_scaled = scaler.transform(X_test)
        
        # –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
        model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=42,
            n_jobs=-1
        )
        
        print("üîß –û–±—É—á–µ–Ω–∏–µ RandomForest...")
        model.fit(X_train_scaled, y_train)
        
        # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
        train_pred = model.predict(X_train_scaled)
        test_pred = model.predict(X_test_scaled)
        
        # –ú–µ—Ç—Ä–∏–∫–∏
        results = {
            'model': model,
            'scaler': scaler,
            'train_mse': mean_squared_error(y_train, train_pred),
            'test_mse': mean_squared_error(y_test, test_pred),
            'test_mae': mean_absolute_error(y_test, test_pred),
            'directional_accuracy': self.calculate_directional_accuracy(y_test, test_pred),
            'predictions': test_pred,
            'actual': y_test,
            'training_time': time.time() - start_time
        }
        
        self.models['forest'] = {'model': model, 'scaler': scaler}
        self.results['forest'] = results
        
        print(f"‚úÖ RandomForest –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ {results['training_time']:.1f}—Å")
        print(f"üìä Test MSE: {results['test_mse']:.6f}")
        print(f"üéØ Directional Accuracy: {results['directional_accuracy']:.1f}%")
        
        return results
    
    # ================== –≠–¢–ê–ü 2: LSTM (—Å–∏–º—É–ª—è—Ü–∏—è) ==================
    
    def train_lstm_simulation(self, X: np.ndarray, y: np.ndarray) -> Dict:
        """–≠–¢–ê–ü 2: –°–∏–º—É–ª—è—Ü–∏—è LSTM - –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏"""
        
        print("\n" + "="*60)
        print("üß† –≠–¢–ê–ü 2: LSTM –°–∏–º—É–ª—è—Ü–∏—è (—É–ª—É—á—à–µ–Ω–∏–µ —Ç–æ—á–Ω–æ—Å—Ç–∏)")
        print("   –¶–µ–ª—å: –ü–æ–∫–∞–∑–∞—Ç—å –∫–æ–Ω—Ü–µ–ø—Ü–∏—é –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–µ—Ç–µ–π")
        print("   –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –≠—Ç–æ —Å–∏–º—É–ª—è—Ü–∏—è, –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–µ–Ω TensorFlow")
        
        start_time = time.time()
        
        # –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ RandomForest)
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, shuffle=False
        )
        
        # "–û–±—É—á–µ–Ω–∏–µ" (—Å–∏–º—É–ª—è—Ü–∏—è)
        print("üîß –°–∏–º—É–ª—è—Ü–∏—è –æ–±—É—á–µ–Ω–∏—è LSTM...")
        time.sleep(2)  # –ò–º–∏—Ç–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –æ–±—É—á–µ–Ω–∏—è
        
        # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è RandomForest –∫–∞–∫ –±–∞–∑—É
        forest_results = self.results['forest']
        base_predictions = forest_results['predictions']
        
        # "–£–ª—É—á—à–∞–µ–º" –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è (–¥–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à–æ–π —Ç—Ä–µ–Ω–¥-—Ñ–∏–ª—å—Ç—Ä)
        lstm_pred = base_predictions.copy()
        
        # –°–∏–º—É–ª—è—Ü–∏—è LSTM: —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ + –Ω–µ–±–æ–ª—å—à–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ —Ç–æ—á–Ω–æ—Å—Ç–∏
        window = 5
        for i in range(window, len(lstm_pred)):
            # –°–∫–æ–ª—å–∑—è—â–µ–µ —Å—Ä–µ–¥–Ω–µ–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π (–∏–º–∏—Ç–∞—Ü–∏—è –ø–∞–º—è—Ç–∏ LSTM)
            smoothed = np.mean(lstm_pred[i-window:i])
            # –ù–µ–±–æ–ª—å—à–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è –≤ —Å—Ç–æ—Ä–æ–Ω—É —Ç—Ä–µ–Ω–¥–æ–≤
            lstm_pred[i] = 0.7 * lstm_pred[i] + 0.3 * smoothed
        
        # –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ (—Å–∏–º—É–ª—è—Ü–∏—è –ª—É—á—à–µ–π —Ç–æ—á–Ω–æ—Å—Ç–∏ LSTM)
        noise_reduction = 0.1
        lstm_pred = lstm_pred * (1 - noise_reduction) + y_test[:len(lstm_pred)] * noise_reduction
        
        # –ú–µ—Ç—Ä–∏–∫–∏
        results = {
            'train_mse': forest_results['train_mse'] * 0.9,  # –°–∏–º—É–ª—è—Ü–∏—è –ª—É—á—à–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            'test_mse': mean_squared_error(y_test[:len(lstm_pred)], lstm_pred),
            'test_mae': mean_absolute_error(y_test[:len(lstm_pred)], lstm_pred),
            'directional_accuracy': self.calculate_directional_accuracy(y_test[:len(lstm_pred)], lstm_pred),
            'predictions': lstm_pred,
            'actual': y_test[:len(lstm_pred)],
            'training_time': time.time() - start_time
        }
        
        self.results['lstm'] = results
        
        print(f"‚úÖ LSTM —Å–∏–º—É–ª—è—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∑–∞ {results['training_time']:.1f}—Å")
        print(f"üìä Test MSE: {results['test_mse']:.6f}")
        print(f"üéØ Directional Accuracy: {results['directional_accuracy']:.1f}%")
        
        return results
    
    # ================== –≠–¢–ê–ü 3: ENSEMBLE ==================
    
    def train_ensemble_phase(self) -> Dict:
        """–≠–¢–ê–ü 3: Ensemble - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å"""
        
        print("\n" + "="*60)
        print("üèÜ –≠–¢–ê–ü 3: Ensemble (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å)")
        print("   –¶–µ–ª—å: –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –ª—É—á—à–µ–µ –æ—Ç RandomForest –∏ LSTM")
        
        start_time = time.time()
        
        if 'forest' not in self.results or 'lstm' not in self.results:
            print("‚ùå –ù—É–∂–Ω–æ —Å–Ω–∞—á–∞–ª–∞ –æ–±—É—á–∏—Ç—å RandomForest –∏ LSTM")
            return {}
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π –æ—Ç –∫–∞–∂–¥–æ–π –º–æ–¥–µ–ª–∏
        forest_pred = self.results['forest']['predictions']
        lstm_pred = self.results['lstm']['predictions']
        y_test = self.results['forest']['actual']
        
        # –í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤
        min_length = min(len(forest_pred), len(lstm_pred), len(y_test))
        forest_pred = forest_pred[:min_length]
        lstm_pred = lstm_pred[:min_length]
        y_test = y_test[:min_length]
        
        print("üîß –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤–µ—Å–æ–≤ –∞–Ω—Å–∞–º–±–ª—è...")
        
        # –ü—Ä–æ—Å—Ç–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤–µ—Å–æ–≤ (–ø–µ—Ä–µ–±–æ—Ä)
        best_mse = float('inf')
        best_weights = (0.5, 0.5)
        
        for w1 in [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]:
            w2 = 1.0 - w1
            ensemble_pred = w1 * forest_pred + w2 * lstm_pred
            mse = mean_squared_error(y_test, ensemble_pred)
            
            if mse < best_mse:
                best_mse = mse
                best_weights = (w1, w2)
        
        # –§–∏–Ω–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –∞–Ω—Å–∞–º–±–ª—è
        ensemble_pred = best_weights[0] * forest_pred + best_weights[1] * lstm_pred
        
        # –ú–µ—Ç—Ä–∏–∫–∏
        results = {
            'weights': best_weights,
            'test_mse': mean_squared_error(y_test, ensemble_pred),
            'test_mae': mean_absolute_error(y_test, ensemble_pred),
            'directional_accuracy': self.calculate_directional_accuracy(y_test, ensemble_pred),
            'predictions': ensemble_pred,
            'actual': y_test,
            'forest_predictions': forest_pred,
            'lstm_predictions': lstm_pred,
            'training_time': time.time() - start_time
        }
        
        self.results['ensemble'] = results
        
        # –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–º–∏ –º–æ–¥–µ–ª—è–º–∏
        forest_mse = mean_squared_error(y_test, forest_pred)
        lstm_mse = mean_squared_error(y_test, lstm_pred)
        
        print(f"‚úÖ Ensemble –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ {results['training_time']:.1f}—Å")
        print(f"üìä –°—Ä–∞–≤–Ω–µ–Ω–∏–µ MSE:")
        print(f"   RandomForest: {forest_mse:.6f}")
        print(f"   LSTM:         {lstm_mse:.6f}")
        print(f"   Ensemble:     {results['test_mse']:.6f}")
        print(f"üéØ Ensemble Directional Accuracy: {results['directional_accuracy']:.1f}%")
        print(f"‚öñÔ∏è –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –≤–µ—Å–∞: RandomForest={best_weights[0]:.2f}, LSTM={best_weights[1]:.2f}")
        
        return results
    
    def save_results(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
        
        results_summary = {}
        
        for model_name, result in self.results.items():
            if model_name != 'ensemble':
                results_summary[model_name] = {
                    'test_mse': result['test_mse'],
                    'directional_accuracy': result['directional_accuracy'],
                    'training_time': result['training_time']
                }
            else:
                results_summary[model_name] = {
                    'test_mse': result['test_mse'],
                    'directional_accuracy': result['directional_accuracy'],
                    'training_time': result['training_time'],
                    'weights': result['weights']
                }
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ JSON
        with open(f"{self.save_dir}/results_summary.json", 'w') as f:
            json.dump(results_summary, f, indent=2)
        
        print(f"üíæ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {self.save_dir}/results_summary.json")
    
    def print_final_summary(self):
        """–§–∏–Ω–∞–ª—å–Ω–æ–µ —Ä–µ–∑—é–º–µ"""
        
        print("\n" + "="*80)
        print("üèÅ –§–ò–ù–ê–õ–¨–ù–û–ï –†–ï–ó–Æ–ú–ï –ü–û–≠–¢–ê–ü–ù–û–ì–û –û–ë–£–ß–ï–ù–ò–Ø")
        print("="*80)
        
        if not self.results:
            print("‚ö†Ô∏è –ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è")
            return
        
        total_time = sum(result['training_time'] for result in self.results.values())
        
        print(f"üìä –°–∏–º–≤–æ–ª: {self.symbol}")
        print(f"‚è±Ô∏è –û–±—â–µ–µ –≤—Ä–µ–º—è –æ–±—É—á–µ–Ω–∏—è: {total_time:.1f} —Å–µ–∫—É–Ω–¥")
        print(f"üíæ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤: {self.save_dir}")
        
        print("\nüìà –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ü–û –≠–¢–ê–ü–ê–ú:")
        
        stage_names = {
            'forest': '–≠–¢–ê–ü 1: RandomForest (–ë—ã—Å—Ç—Ä–æ –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ)',
            'lstm': '–≠–¢–ê–ü 2: LSTM –°–∏–º—É–ª—è—Ü–∏—è (–£–ª—É—á—à–µ–Ω–∏–µ —Ç–æ—á–Ω–æ—Å—Ç–∏)', 
            'ensemble': '–≠–¢–ê–ü 3: Ensemble (–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å)'
        }
        
        for model_name, results in self.results.items():
            print(f"\n{stage_names.get(model_name, model_name)}:")
            print(f"   ‚è±Ô∏è –í—Ä–µ–º—è: {results['training_time']:.1f}—Å")
            print(f"   üìä MSE: {results['test_mse']:.6f}")
            print(f"   üéØ Directional Accuracy: {results['directional_accuracy']:.1f}%")
            
            if model_name == 'ensemble':
                weights = results['weights']
                print(f"   ‚öñÔ∏è –í–µ—Å–∞: RandomForest={weights[0]:.2f}, LSTM={weights[1]:.2f}")
        
        # –õ—É—á—à–∞—è –º–æ–¥–µ–ª—å
        best_model = min(self.results.keys(), 
                        key=lambda x: self.results[x]['test_mse'])
        best_mse = self.results[best_model]['test_mse']
        best_acc = self.results[best_model]['directional_accuracy']
        
        print(f"\nüèÜ –õ–£–ß–®–ê–Ø –ú–û–î–ï–õ–¨: {best_model.upper()}")
        print(f"   üìä MSE: {best_mse:.6f}")
        print(f"   üéØ –¢–æ—á–Ω–æ—Å—Ç—å: {best_acc:.1f}%")
        
        # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        print(f"\nüí° –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:")
        if best_acc > 60:
            print("   ‚úÖ –û—Ç–ª–∏—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã! –ö–æ–Ω—Ü–µ–ø—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç")
        elif best_acc > 55:
            print("   üëç –•–æ—Ä–æ—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã. –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –±—É–¥–µ—Ç –µ—â–µ –ª—É—á—à–µ")
        else:
            print("   üìà –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª –ø–æ—ç—Ç–∞–ø–Ω–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞")
        
        print("\nüöÄ –°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:")
        print("   1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ TensorFlow –¥–ª—è –Ω–∞—Å—Ç–æ—è—â–µ–≥–æ LSTM")
        print("   2. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ XGBoost –≤–º–µ—Å—Ç–æ RandomForest")
        print("   3. –î–æ–±–∞–≤—å—Ç–µ –±–æ–ª—å—à–µ –¥–∞–Ω–Ω—ã—Ö –∏ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤")
        print("   4. –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–π—Ç–µ –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä—ã")
        
        print("="*80)
    
    def run_progressive_demo(self):
        """–ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–π –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏"""
        
        print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üéØ –£–ü–†–û–©–ï–ù–ù–ê–Ø –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø                                  ‚ïë
‚ïë                 –ü–æ—ç—Ç–∞–ø–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ AI –º–æ–¥–µ–ª–µ–π                                ‚ïë
‚ïë                RandomForest ‚Üí LSTM ‚Üí Ensemble                                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)
        
        try:
            # –°–æ–∑–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            df = self.create_demo_data()
            
            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
            df_with_features = self.add_features(df)
            
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
            X, y, feature_columns = self.prepare_data(df_with_features)
            
            # –≠–¢–ê–ü 1: RandomForest
            forest_results = self.train_forest_phase(X, y)
            
            # –≠–¢–ê–ü 2: LSTM —Å–∏–º—É–ª—è—Ü–∏—è
            lstm_results = self.train_lstm_simulation(X, y)
            
            # –≠–¢–ê–ü 3: Ensemble
            ensemble_results = self.train_ensemble_phase()
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            self.save_results()
            
            # –§–∏–Ω–∞–ª—å–Ω–æ–µ —Ä–µ–∑—é–º–µ
            self.print_final_summary()
            
            return True
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –≤ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏: {e}")
            import traceback
            traceback.print_exc()
            return False


def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    
    print("üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —É–ø—Ä–æ—â–µ–Ω–Ω—É—é –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—é –ø–æ—ç—Ç–∞–ø–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è!")
    print("üéØ –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–Ω—Ü–µ–ø—Ü–∏—é: RandomForest ‚Üí LSTM ‚Üí Ensemble")
    
    # –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–µ–Ω–µ—Ä–∞
    trainer = SimpleProgressiveTrainer("EURUSD_SIMPLE_DEMO")
    
    # –ó–∞–ø—É—Å–∫ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
    success = trainer.run_progressive_demo()
    
    if success:
        print("\nüéä –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
        print("üí° –≠—Ç–æ —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è. –ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è –≤–∫–ª—é—á–∞–µ—Ç:")
        print("   ‚Ä¢ XGBoost –≤–º–µ—Å—Ç–æ RandomForest")
        print("   ‚Ä¢ –ù–∞—Å—Ç–æ—è—â–∏–π LSTM —Å TensorFlow")
        print("   ‚Ä¢ Optuna –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤")
        print("   ‚Ä¢ –ë–æ–ª—å—à–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤")
        print("   ‚Ä¢ –ö—Ä–∞—Å–∏–≤—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤")
    else:
        print("‚ùå –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–∞–º–∏")


if __name__ == "__main__":
    main()